cons_merge(my_tree$right_arg)
}
violations
violations
is_empty(left_mc)
NULL
# check if tree has children
violations <- 0
left_mc <- my_tree$left_arg$mc %>% str_split(",") %>% unlist()
for_left_lb <- my_tree$right_arg$lb %>% as.character()
any(left_mc == for_left_lb)
is_empty(left_mc)
if (any(left_mc == for_left_lb)){
NULL
} else if (is_empty(left_mc)){
NULL
} else {violations %<>% +1}
violations
# check right
right_mc <- my_tree$right_arg$mc %>% str_split(",") %>% unlist()
for_right_lb <- my_tree$left_arg$lb %>% as.character()
any(right_mc == for_right_lb)
is_empty(right_mc)
right_mc
# check if tree has children
violations <- 0
if (isNotLeaf(my_tree)){
# check left
left_mc <- my_tree$left_arg$mc %>% str_split(",") %>% unlist() %>% as.integer()
for_left_lb <- my_tree$right_arg$lb
if (any(left_mc == for_left_lb)){
NULL
} else if (is_na(left_mc)){
NULL
} else {violations %<>% +1}
# check right
right_mc <- my_tree$right_arg$mc %>% str_split(",") %>% unlist() %>% as.integer()
for_right_lb <- my_tree$left_arg$lb
if (any(right_mc == for_right_lb)){
NULL
} else if (is_na(right_mc)){
NULL
} else {violations %<>% +1}
# recurse left
cons_merge(my_tree$left_arg)
# recurse right
cons_merge(my_tree$right_arg)
}
right_mc
left_mc
is_na(right_mc)
is.na(right_mc)
# check if tree has children
violations <- 0
if (isNotLeaf(my_tree)){
# check left
left_mc <- my_tree$left_arg$mc %>% str_split(",") %>% unlist() %>% as.integer()
for_left_lb <- my_tree$right_arg$lb
if (any(left_mc == for_left_lb)){
NULL
} else if (is.na(left_mc)){
NULL
} else {violations %<>% +1}
# check right
right_mc <- my_tree$right_arg$mc %>% str_split(",") %>% unlist() %>% as.integer()
for_right_lb <- my_tree$left_arg$lb
if (any(right_mc == for_right_lb)){
NULL
} else if (is.na(right_mc)){
NULL
} else {violations %<>% +1}
# recurse left
cons_merge(my_tree$left_arg)
# recurse right
cons_merge(my_tree$right_arg)
}
right_mc
for_right_lb
# check if tree has children
violations <- 0
if (isNotLeaf(my_tree)){
# check left
left_mc <- my_tree$left_arg$mc %>% str_split(",") %>% unlist() %>% as.integer()
for_left_lb <- my_tree$right_arg$lb
if (any(for_left_lb == left_mc)){
NULL
} else if (is.na(left_mc)){
NULL
} else {violations %<>% +1}
# check right
right_mc <- my_tree$right_arg$mc %>% str_split(",") %>% unlist() %>% as.integer()
for_right_lb <- my_tree$left_arg$lb
if (any(for_right_lb == right_mc)){
NULL
} else if (is.na(right_mc)){
NULL
} else {violations %<>% +1}
# recurse left
cons_merge(my_tree$left_arg)
# recurse right
cons_merge(my_tree$right_arg)
}
for_right_lb
right_mc
?any
any(for_right_lb == right_mc, na.rm = T)
# check if tree has children
violations <- 0
if (isNotLeaf(my_tree)){
# check left
left_mc <- my_tree$left_arg$mc %>% str_split(",") %>% unlist() %>% as.integer()
for_left_lb <- my_tree$right_arg$lb
if (any(for_left_lb == left_mc, na.rm = T)){
NULL
} else if (is.na(left_mc)){
NULL
} else {violations %<>% +1}
# check right
right_mc <- my_tree$right_arg$mc %>% str_split(",") %>% unlist() %>% as.integer()
for_right_lb <- my_tree$left_arg$lb
if (any(for_right_lb == right_mc, na.rm = T)){
NULL
} else if (is.na(right_mc)){
NULL
} else {violations %<>% +1}
# recurse left
cons_merge(my_tree$left_arg)
# recurse right
cons_merge(my_tree$right_arg)
}
library(tidyverse)
library(magrittr)
library(philentropy)  # KL function
library(optimx)       # optimizing function
library(data.tree)
source("./machinery2.0/updated_gen_functions.R")
source("./machinery2.0/updated_eval_functions.R")
source("./machinery2.0/updated_draw_latex.R")
source("./machinery2.0/weight_optimizer.R")
df <- read.csv("basic_numeration.csv", na.strings = "NA") %>%
mutate(mc = ifelse(is.na(mc), "", mc))
my_list <- list()
mergeMC("DP1","V",numeration = df) %>% labelMC() %>% mergeMC("v", df) %>% labelMC() %>% moveMC()
print(my_list[[3]], "it","lb","mc","m_vio","is_copy")
my_tree <- Clone(my_list[[3]])
my_tree %>% cons_merge()
# MERGE CONDITION CONSTRAINT, iteratively check downwards
cons_merge <- function(my_tree){
# check if tree has children
violations <- 0
if (isNotLeaf(my_tree)){
# check left
left_mc <- my_tree$left_arg$mc %>% str_split(",") %>% unlist() %>% as.integer()
for_left_lb <- my_tree$right_arg$lb
if (any(for_left_lb == left_mc, na.rm = T)){
NULL
} else if (is.na(left_mc)){
NULL
} else {violations %<>% +1}
# check right
right_mc <- my_tree$right_arg$mc %>% str_split(",") %>% unlist() %>% as.integer()
for_right_lb <- my_tree$left_arg$lb
if (any(for_right_lb == right_mc, na.rm = T)){
NULL
} else if (is.na(right_mc)){
NULL
} else {violations %<>% +1}
# recurse left
cons_merge(my_tree$left_arg)
# recurse right
cons_merge(my_tree$right_arg)
}
# return result
return(violations)
}
my_tree %>% cons_merge()
library(tidyverse)
library(magrittr)
library(philentropy)  # KL function
library(optimx)       # optimizing function
library(data.tree)
source("./machinery2.0/updated_gen_functions.R")
source("./machinery2.0/updated_eval_functions.R")
source("./machinery2.0/updated_draw_latex.R")
source("./machinery2.0/weight_optimizer.R")
df <- read.csv("basic_numeration.csv", na.strings = "NA") %>%
mutate(mc = ifelse(is.na(mc), "", mc))
my_list <- list()
mergeMC("DP1","V",numeration = df) %>% labelMC() %>% mergeMC("v", df) %>% labelMC() %>% moveMC()
print(my_list[[3]], "it","lb","mc","m_vio","is_copy")
my_tree <- Clone(my_list[[3]])
my_tree %>% cons_merge()
# check left
left_mc <- my_tree$left_arg$mc %>% str_split(",") %>% unlist() %>% as.integer()
for_left_lb <- my_tree$right_arg$lb
any(for_left_lb == left_mc, na.rm = T)
is.na(left_mc)
left_mc
# check right
right_mc <- my_tree$right_arg$mc %>% str_split(",") %>% unlist() %>% as.integer()
for_right_lb <- my_tree$left_arg$lb
right_mc
any(for_right_lb == right_mc, na.rm = T)
is.na(right_mc)
is.na(right_mc) || is_empty(right_mc)
library(tidyverse)
library(magrittr)
library(philentropy)  # KL function
library(optimx)       # optimizing function
library(data.tree)
source("./machinery2.0/updated_gen_functions.R")
source("./machinery2.0/updated_eval_functions.R")
source("./machinery2.0/updated_draw_latex.R")
source("./machinery2.0/weight_optimizer.R")
df <- read.csv("basic_numeration.csv", na.strings = "NA") %>%
mutate(mc = ifelse(is.na(mc), "", mc))
my_list <- list()
mergeMC("DP1","V",numeration = df) %>% labelMC() %>% mergeMC("v", df) %>% labelMC() %>% moveMC()
print(my_list[[3]], "it","lb","mc","m_vio","is_copy")
my_tree <- Clone(my_list[[3]])
my_tree %>% cons_merge()
# MERGE CONDITION CONSTRAINT, iteratively check downwards
cons_merge <- function(my_tree){
# check if tree has children
violations <- 0
if (isNotLeaf(my_tree)){
# check left
left_mc <- my_tree$left_arg$mc %>% str_split(",") %>% unlist() %>% as.integer()
for_left_lb <- my_tree$right_arg$lb
if (any(for_left_lb == left_mc, na.rm = T)){
NULL
} else if (is.na(left_mc) || is_empty(left_mc)){
NULL
} else {violations %<>% +1}
# check right
right_mc <- my_tree$right_arg$mc %>% str_split(",") %>% unlist() %>% as.integer()
for_right_lb <- my_tree$left_arg$lb
if (any(for_right_lb == right_mc, na.rm = T)){
NULL
} else if (is.na(right_mc) || is_empty(right_mc)){
NULL
} else {violations %<>% +1}
# recurse left
cons_merge(my_tree$left_arg)
# recurse right
cons_merge(my_tree$right_arg)
}
# return result
return(violations)
}
my_tree %>% cons_merge()
library(tidyverse)
library(magrittr)
library(philentropy)  # KL function
library(optimx)       # optimizing function
library(data.tree)
source("./machinery2.0/updated_gen_functions.R")
source("./machinery2.0/updated_eval_functions.R")
source("./machinery2.0/updated_draw_latex.R")
source("./machinery2.0/weight_optimizer.R")
df <- read.csv("basic_numeration.csv", na.strings = "NA") %>%
mutate(mc = ifelse(is.na(mc), "", mc))
my_list <- list()
mergeMC("DP1","V",numeration = df) %>% labelMC() %>% mergeMC("v", df) %>% labelMC() %>% moveMC()
print(my_list[[3]], "it","lb","mc","m_vio","is_copy")
my_tree <- Clone(my_list[[3]])
my_tree %>% cons_merge()
# MERGE CONDITION CONSTRAINT, iteratively check downwards
cons_merge <- function(my_tree){
# check if tree has children
violations <- 0
if (isNotLeaf(my_tree)){
# check left
left_mc <- my_tree$left_arg$mc %>% str_split(",") %>% unlist() %>% as.integer()
for_left_lb <- my_tree$right_arg$lb
if (any(for_left_lb == left_mc, na.rm = T)){
NULL
} else if (is.na(left_mc) || is_empty(left_mc)){
NULL
} else {violations %<>% +1}
# check right
right_mc <- my_tree$right_arg$mc %>% str_split(",") %>% unlist() %>% as.integer()
for_right_lb <- my_tree$left_arg$lb
if (any(for_right_lb == right_mc, na.rm = T)){
NULL
} else if (is.na(right_mc) || is_empty(right_mc)){
NULL
} else {violations %<>% +1}
# recurse left
cons_merge(my_tree$left_arg)
# recurse right
cons_merge(my_tree$right_arg)
}
eval <- tibble(mc = violations)
# return result
return(eval)
}
my_tree %>% cons_merge()
library(tidyverse)
library(magrittr)
library(philentropy)  # KL function
library(optimx)       # optimizing function
library(data.tree)
source("./machinery2.0/updated_gen_functions.R")
source("./machinery2.0/updated_eval_functions.R")
source("./machinery2.0/updated_draw_latex.R")
source("./machinery2.0/weight_optimizer.R")
df <- read.csv("basic_numeration.csv", na.strings = "NA") %>%
mutate(mc = ifelse(is.na(mc), "", mc))
my_list <- list()
mergeMC("DP1","V",numeration = df) %>% labelMC() %>% mergeMC("v", df) %>% labelMC() %>% moveMC()
my_tree <- Clone(my_list[[3]]) %>% mergeMC("T",df)
print(my_tree, "it","lb","mc","m_vio","is_copy")
my_tree %>% cons_merge()
# MERGE CONDITION CONSTRAINT, iteratively check downwards
cons_merge <- function(my_tree){
# check if tree has children
violations <- 0
if (isNotLeaf(my_tree)){
# check left
left_mc <- my_tree$left_arg$mc %>% str_split(",") %>% unlist() %>% as.integer()
for_left_lb <- my_tree$right_arg$lb
if (any(for_left_lb == left_mc, na.rm = T)){
NULL
} else if (is.na(left_mc) || is_empty(left_mc)){
NULL
} else {violations %<>% +1}
# check right
right_mc <- my_tree$right_arg$mc %>% str_split(",") %>% unlist() %>% as.integer()
for_right_lb <- my_tree$left_arg$lb
if (any(for_right_lb == right_mc, na.rm = T)){
NULL
} else if (is.na(right_mc) || is_empty(right_mc)){
NULL
} else {violations %<>% +1}
# recurse left
cons_merge(my_tree$left_arg)
# recurse right
cons_merge(my_tree$right_arg)
}
eval <- tibble(mc = violations)
# return result
return(eval)
}
my_tree %>% cons_merge()
left_mc <- my_tree$left_arg$mc %>% str_split(",") %>% unlist() %>% as.integer()
for_left_lb <- my_tree$right_arg$lb
left_mc
for_left_lb
any(for_left_lb == left_mc, na.rm = T)
for_left_lb
is.na(left_mc) || is_empty(left_mc)
# check right
right_mc <- my_tree$right_arg$mc %>% str_split(",") %>% unlist() %>% as.integer()
for_right_lb <- my_tree$left_arg$lb
right_mc
for_right_lb
library(tidyverse)
library(magrittr)
library(philentropy)  # KL function
library(optimx)       # optimizing function
library(data.tree)
source("./machinery2.0/updated_gen_functions.R")
source("./machinery2.0/updated_eval_functions.R")
source("./machinery2.0/updated_draw_latex.R")
source("./machinery2.0/weight_optimizer.R")
df <- read.csv("basic_numeration.csv", na.strings = "NA") %>%
mutate(mc = ifelse(is.na(mc), "", mc))
my_list <- list()
mergeMC("DP1","V",numeration = df) %>% labelMC() %>% mergeMC("v", df) %>% labelMC() %>% moveMC()
my_tree <- Clone(my_list[[3]]) %>% mergeMC("T",df)
print(my_tree, "it","lb","mc","m_vio","is_copy")
my_tree %>% cons_merge()
# MERGE CONDITION CONSTRAINT, iteratively check downwards
cons_merge <- function(my_tree){
# check if tree has children
violations <- 0
if (isNotLeaf(my_tree)){
# check left
left_mc <- my_tree$left_arg$mc %>% str_split(",") %>% unlist() %>% as.integer()
for_left_lb <- my_tree$right_arg$lb
if (any(for_left_lb == left_mc, na.rm = T)){
NULL
} else if (is.na(left_mc) || is_empty(left_mc)){
NULL
} else {violations %<>% +1}
# check right
right_mc <- my_tree$right_arg$mc %>% str_split(",") %>% unlist() %>% as.integer()
for_right_lb <- my_tree$left_arg$lb
if (any(for_right_lb == right_mc, na.rm = T)){
NULL
} else if (is.na(right_mc) || is_empty(right_mc)){
NULL
} else {violations %<>% +1}
# recurse left
cons_merge(my_tree$left_arg)
# recurse right
cons_merge(my_tree$right_arg)
}
# return result
return(violations)
}
my_tree %>% cons_merge()
library(tidyverse)
library(magrittr)
library(philentropy)  # KL function
library(optimx)       # optimizing function
library(data.tree)
source("./machinery2.0/updated_gen_functions.R")
source("./machinery2.0/updated_eval_functions.R")
source("./machinery2.0/updated_draw_latex.R")
source("./machinery2.0/weight_optimizer.R")
df <- read.csv("basic_numeration.csv", na.strings = "NA") %>%
mutate(mc = ifelse(is.na(mc), "", mc))
my_list <- list()
mergeMC("DP1","V",numeration = df) %>% labelMC() %>% mergeMC("v", df) %>% labelMC() %>% moveMC()
my_tree <- Clone(my_list[[3]]) %>% mergeMC("T",df)
print(my_tree, "it","lb","mc","m_vio","is_copy")
my_tree %>% cons_merge()
# MERGE CONDITION CONSTRAINT, iteratively check downwards
cons_merge <- function(my_tree){
# check if tree has children
violations <- 0
if (isNotLeaf(my_tree)){
# check left
left_mc <- my_tree$left_arg$mc %>% str_split(",") %>% unlist() %>% as.integer()
for_left_lb <- my_tree$right_arg$lb
if (any(for_left_lb == left_mc, na.rm = T)){
NULL
} else if (is.na(left_mc) || is_empty(left_mc)){
NULL
} else {violations %<>% +1}
# check right
right_mc <- my_tree$right_arg$mc %>% str_split(",") %>% unlist() %>% as.integer()
for_right_lb <- my_tree$left_arg$lb
if (any(for_right_lb == right_mc, na.rm = T)){
NULL
} else if (is.na(right_mc) || is_empty(right_mc)){
NULL
} else {violations %<>% +1}
# recurse left
cons_merge(my_tree$left_arg)
# recurse right
cons_merge(my_tree$right_arg)
# return result
return(violations + cons_merge(my_tree$left_arg) + cons_merge(my_tree$right_arg))
}
# return result
return(violations)
}
my_tree %>% cons_merge()
library(tidyverse)
library(magrittr)
library(philentropy)  # KL function
library(optimx)       # optimizing function
library(data.tree)
source("./machinery2.0/updated_gen_functions.R")
source("./machinery2.0/updated_eval_functions.R")
source("./machinery2.0/updated_draw_latex.R")
source("./machinery2.0/weight_optimizer.R")
df <- read.csv("basic_numeration.csv", na.strings = "NA") %>%
mutate(mc = ifelse(is.na(mc), "", mc))
my_list <- list()
mergeMC("DP1","V",numeration = df) %>% labelMC() %>% mergeMC("v", df) %>% labelMC() %>% moveMC()
my_tree <- Clone(my_list[[3]]) %>% mergeMC("T",df)
print(my_tree, "it","lb","mc","m_vio","is_copy")
my_tree %>% cons_merge()
# MERGE CONDITION CONSTRAINT, iteratively check downwards
cons_merge <- function(my_tree){
# check if tree has children
violations <- 0
if (isNotLeaf(my_tree)){
# check left
left_mc <- my_tree$left_arg$mc %>% str_split(",") %>% unlist() %>% as.integer()
for_left_lb <- my_tree$right_arg$lb
if (any(for_left_lb == left_mc, na.rm = T)){
NULL
} else if (is.na(left_mc) || is_empty(left_mc)){
NULL
} else {violations %<>% +1}
# check right
right_mc <- my_tree$right_arg$mc %>% str_split(",") %>% unlist() %>% as.integer()
for_right_lb <- my_tree$left_arg$lb
if (any(for_right_lb == right_mc, na.rm = T)){
NULL
} else if (is.na(right_mc) || is_empty(right_mc)){
NULL
} else {violations %<>% +1}
# return head result by recursing
return(violations + cons_merge(my_tree$left_arg) + cons_merge(my_tree$right_arg))
}
# return result for leaf node
return(violations)
}
my_tree %>% cons_merge()
library(tidyverse)
library(magrittr)
library(philentropy)  # KL function
library(optimx)       # optimizing function
library(data.tree)
source("./machinery2.0/updated_gen_functions.R")
source("./machinery2.0/updated_eval_functions.R")
source("./machinery2.0/updated_draw_latex.R")
source("./machinery2.0/weight_optimizer.R")
df <- read.csv("basic_numeration.csv", na.strings = "NA") %>%
mutate(mc = ifelse(is.na(mc), "", mc))
my_list <- list()
mergeMC("DP1","V",numeration = df) %>% labelMC() %>% mergeMC("v", df) %>% labelMC() %>% moveMC()
my_tree <- Clone(my_list[[3]])
print(my_tree, "it","lb","mc","m_vio","is_copy")
my_tree %>% cons_merge()
str(my_tree %>% cons_merge)
